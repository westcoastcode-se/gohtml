package gohtml

import (
	"bytes"
	"io"
	"sync"
	"time"
)

// CacheEntry represents an item inside the cache
type CacheEntry struct {
	evictTime time.Time
	bytes     []byte
	token     byte
}

// CacheStorage makes it possible for us to cache autogenerated data. Useful for, for example, css generation and similar things
type CacheStorage interface {
	Get(key any) (*CacheEntry, bool)
	Set(key any, bytes []byte, token byte, evictDuration time.Duration)
}

type InMemoryCacheStorage struct {
	data map[any]CacheEntry
	lock sync.Mutex
}

func CreateInMemoryCacheStorage() CacheStorage {
	return &InMemoryCacheStorage{
		data: make(map[any]CacheEntry),
		lock: sync.Mutex{},
	}
}

func (cs *InMemoryCacheStorage) Get(key any) (*CacheEntry, bool) {
	cs.lock.Lock()
	defer cs.lock.Unlock()
	item, found := cs.data[key]
	if found {
		if time.Now().After(item.evictTime) {
			return nil, false
		}
		return &item, true
	}
	return nil, false
}

func (cs *InMemoryCacheStorage) Set(key any, bytes []byte, token byte, evictDuration time.Duration) {
	cs.lock.Lock()
	defer cs.lock.Unlock()
	cs.data[key] = CacheEntry{
		evictTime: time.Now().Add(evictDuration),
		bytes:     bytes[:],
		token:     token,
	}
}

// CacheForever represents caching an item forever
const CacheForever = 1000000 * time.Hour

// Cache rendering of all children in the supplied duration. This is normally useful for when
// you have a lot of data fetched from IO
func Cache(cacheStorage CacheStorage, key any, evictDuration time.Duration, c ...Node) Node {
	if item, found := cacheStorage.Get(key); found {
		return func(b byte, w io.Writer) byte {
			_, _ = w.Write(item.bytes)
			return item.token
		}
	}

	return func(b byte, w io.Writer) byte {
		bb := bytes.Buffer{}
		ww := ErrorAwareWriter{w: &bb}
		for _, cc := range c {
			b = cc(b, &ww)
		}
		// if no error happened then actually write the result on the supplied writer
		if ww.err == nil {
			result := bb.Bytes()
			_, _ = w.Write(result[:])
			cacheStorage.Set(key, result[:], b, evictDuration)
		}
		return b
	}
}
