package h

import (
	"bytes"
	"io"
	"sync"
	"time"
)

// CacheEntry represents an item inside the cache
type CacheEntry struct {
	evictTime time.Time
	bytes     []byte
	token     byte
}

// CacheStorage makes it possible for us to cache autogenerated data. Useful for, for example, css generation and similar things
type CacheStorage interface {
	// Invalidate the cached item if found. Returns the item and a boolean that indicates if the item was cached or not
	Invalidate(key any) (*CacheEntry, bool)

	// Get fetches the cached entry, if found. Returns the entry and a boolean that indicates if the entry is valid or not
	Get(key any) (*CacheEntry, bool)

	// Set a value in the cache
	Set(key any, bytes []byte, token byte, evictDuration time.Duration)
}

type InMemoryCacheStorage struct {
	data map[any]*CacheEntry
	lock sync.RWMutex
}

func CreateInMemoryCacheStorage() CacheStorage {
	return &InMemoryCacheStorage{
		data: make(map[any]*CacheEntry),
		lock: sync.RWMutex{},
	}
}

func (cs *InMemoryCacheStorage) Invalidate(key any) (*CacheEntry, bool) {
	cs.lock.Lock()
	defer cs.lock.Unlock()
	item, found := cs.data[key]
	if !found {
		return nil, false
	}
	delete(cs.data, key)
	return item, true
}

func (cs *InMemoryCacheStorage) Get(key any) (*CacheEntry, bool) {
	cs.lock.RLock()
	defer cs.lock.RUnlock()
	item, found := cs.data[key]
	if found {
		if time.Now().After(item.evictTime) {
			return nil, false
		}
		return item, true
	}
	return nil, false
}

func (cs *InMemoryCacheStorage) Set(key any, bytes []byte, token byte, evictDuration time.Duration) {
	cs.lock.Lock()
	defer cs.lock.Unlock()
	// Really verify that the value isn't set
	if cs.isValid(key) {
		return
	}

	cs.data[key] = &CacheEntry{
		evictTime: time.Now().Add(evictDuration),
		bytes:     bytes[:],
		token:     token,
	}
}

// isValid does a double check if the value isn't really valid
func (cs *InMemoryCacheStorage) isValid(key any) bool {
	item, found := cs.data[key]
	if !found {
		return false
	}
	return time.Now().After(item.evictTime)
}

// CacheForever represents caching an item forever
const CacheForever = 1000000 * time.Hour

// Cache rendering of all children in the supplied duration. This is normally useful for when
// you have a lot of data fetched from IO
func Cache(cacheStorage CacheStorage, key any, evictDuration time.Duration, c ...Node) Node {
	if item, found := cacheStorage.Get(key); found {
		return func(b byte, w io.Writer) byte {
			_, _ = w.Write(item.bytes)
			return item.token
		}
	}

	return func(b byte, w io.Writer) byte {
		bb := bytes.Buffer{}
		ww := errorAwareWriter{w: &bb}
		for _, cc := range c {
			b = cc(b, &ww)
		}
		// if no error happened then actually write the result on the supplied writer
		if ww.err == nil {
			result := bb.Bytes()
			_, _ = w.Write(result[:])
			cacheStorage.Set(key, result[:], b, evictDuration)
		}
		return b
	}
}
